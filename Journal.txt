This is a lightweight journal of the steps for the Tom Looman course. The hope is to capture any snags or "gotchas"
and what I did as a work-around. I will keep the notes short and to the point (not intended to re-write the course notes):


Lecture 1:

	- He used UE 4.25 in the original course. I'm using UE 5.6

Lecture 2:

	- Some differences for UE 5.6
		+ Enhanced input is available and the old input system is deprecated. I will used the old input system
			for now, but I plan to upgrade it after I get the whole system working (later).
		+ The old VFX system is also deprecated. I chose to go ahead and upgrade to Niagara, so there were a
			few steps to get basic Niagara working.

Lecture 3:


Lecture 4: Interfaces and Collision Queries

	4.1 : Interfaces
		- create an interface component derived from UActorComponent : USInteractionComponent

	4.2 : Actor Components / Collision
		- Using Actor components to separate various functionality within the SCharacter class (by composition).
		- create USInteractionComponent
			+ responsible for  handling a character's interactions with objects in the scene (e.g. a treasure chest)
		- COOL : Notice how you can bind the interface's "Interact" function from the AActor (APawn - by way of the
			interaction component) that is interested in performing interactions:

				void USInteractionComponent::PrimaryInteract()
				{

					// perform query to determine if we are near an "interactable" object

					FHitResult OutHitResult;
					FCollisionObjectQueryParams ObjectQueryParams;
					ObjectQueryParams.AddObjectTypesToQuery(ECC_WorldDynamic);

					FVector EyeLocation;
					FRotator EyeRotation;

					AActor* MyOwner = GetOwner();
					MyOwner->GetActorEyesViewPoint(EyeLocation, EyeRotation);

					FVector End = EyeLocation + (EyeRotation.Vector()*1000);


					GetWorld()->LineTraceSingleByObjectType(OutHitResult, EyeLocation, End, ObjectQueryParams);

					// debugging : draw the query line - might need to do this
					const float Lifetime = 2.0f;
				    DrawDebugLine(GetWorld(), EyeLocation, End, FColor::Red, false, Lifetime, 0, 2.0f);

					AActor* HitActor = OutHitResult.GetActor();

					if(HitActor && HitActor->Implements<USGameplayInterface>() )
					{
						APawn* OwnerPawn = Cast<APawn>(GetOwner());
						ISGameplayInterface::Execute_Interact(HitActor, OwnerPawn);
					}

				}
		- 17:24 : The InteractionComp absolutely should exist at this point, so I will use an assert here
			instead of branch guards

		- 25:50 : got it working fine with the line trace ... checkpointing code

Commit : Lecture 4.2 a : ActorComponents & Collision

		- continuing Lecture ... sphere sweep tests
			+ note: I will keep the line trace and create a new sphere sweep trace just so I have both for reference

		- finished adding the line and sphere trace versions ... Lecture 4.2 complete. checkpoint code

Commit : Lecture 4.2 b : ActorComponents & Collision

	4.3 : Animations and Timers

		- Adding an animation to our character during his attack
			+ note - this is easy since we already have the animations for it from Paragon!
		- Add a variable called AttackAnim to the ASCharacter (type = UAnimMontage*) ... allows us to bind in Editor
		- Using UPROPERTY Category = "Attack" to help organize the BP layout
		- for now we use a timer to control moment the projectile spawns ... eventually (better) approach will
			use anim notify or other techniques.

		- completed Lecture 4.3 .... checkpoint code

Commit : Lecture 4.3 : Animations and Timers


Lecture 5.1
	- intro to BPs

Lecture 5.2
	- create a BP class derived from AActor for a "Lever"
	- You can modify the BP so it will implement our C++ interaction interface !
		+ go to Class Settings
		+ Add "SGameplayInterface" to list of Implemented Interfaces
			> recall we had an overridable BPE in this C++ interface! , called "Interact"
		+ We now see the "Interact" function listed in the My Blueprint tab under INTERFACES on the right.
		+ double-click it... you'll now see an event in the event graph to provide BP "code" for this event.

		+ we didn't mark up the "Interact" BPE to be BP Callable though, so we need to edit the code for it now

Lecture 5.3
	- when you implement the "Interact" BPE in Blueprint for the treasure chest, it will OVERRIDE the C++ code in the base class
		so only operations performed in the Blueprint "code" will be executed.
		> (? maybe there's a way to also call the C++ native function directly within the BP code so you could then "append" to
			the C++ code ?)
		> Aha YES - Add Call To Parent Function in BP ... they already though about this

		> right click on the "Event Interact" node in BP graph to place the "Add Call To Parent"

	- introduced the "timeline" node in BP


	- checkpoint code and data:

Commit : Lecture 5.3 : Animating in Blueprint

Lecture 5.4 Projectile Blueprint & Collision

	- more improvements to the projectile with VFX on impact and destroy on impact
	- details discussed about differences between events and functions in BP




