This is a lightweight journal of the steps for the Tom Looman course. The hope is to capture any snags or "gotchas"
and what I did as a work-around. I will keep the notes short and to the point (not intended to re-write the course notes):


Lecture 1:

	- He used UE 4.25 in the original course. I'm using UE 5.6

Lecture 2:

	- Some differences for UE 5.6
		+ Enhanced input is available and the old input system is deprecated. I will used the old input system
			for now, but I plan to upgrade it after I get the whole system working (later).
		+ The old VFX system is also deprecated. I chose to go ahead and upgrade to Niagara, so there were a
			few steps to get basic Niagara working.

Lecture 3:


Lecture 4: Interfaces and Collision Queries

	4.1 : Interfaces
		- create an interface component derived from UActorComponent : USInteractionComponent

	4.2 : Actor Components / Collision
		- Using Actor components to separate various functionality within the SCharacter class (by composition).
		- create USInteractionComponent
			+ responsible for  handling a character's interactions with objects in the scene (e.g. a treasure chest)
		- COOL : Notice how you can bind the interface's "Interact" function from the AActor (APawn - by way of the
			interaction component) that is interested in performing interactions:

				void USInteractionComponent::PrimaryInteract()
				{

					// perform query to determine if we are near an "interactable" object

					FHitResult OutHitResult;
					FCollisionObjectQueryParams ObjectQueryParams;
					ObjectQueryParams.AddObjectTypesToQuery(ECC_WorldDynamic);

					FVector EyeLocation;
					FRotator EyeRotation;

					AActor* MyOwner = GetOwner();
					MyOwner->GetActorEyesViewPoint(EyeLocation, EyeRotation);

					FVector End = EyeLocation + (EyeRotation.Vector()*1000);


					GetWorld()->LineTraceSingleByObjectType(OutHitResult, EyeLocation, End, ObjectQueryParams);

					// debugging : draw the query line - might need to do this
					const float Lifetime = 2.0f;
				    DrawDebugLine(GetWorld(), EyeLocation, End, FColor::Red, false, Lifetime, 0, 2.0f);

					AActor* HitActor = OutHitResult.GetActor();

					if(HitActor && HitActor->Implements<USGameplayInterface>() )
					{
						APawn* OwnerPawn = Cast<APawn>(GetOwner());
						ISGameplayInterface::Execute_Interact(HitActor, OwnerPawn);
					}

				}
		- 17:24 : The InteractionComp absolutely should exist at this point, so I will use an assert here
			instead of branch guards

		- 25:50 : got it working fine with the line trace ... checkpointing code

Commit : Lecture 4.2 a : ActorComponents & Collision

		- continuing Lecture ... sphere sweep tests
			+ note: I will keep the line trace and create a new sphere sweep trace just so I have both for reference

		- finished adding the line and sphere trace versions ... Lecture 4.2 complete. checkpoint code

Commit : Lecture 4.2 b : ActorComponents & Collision

	4.3 : Animations and Timers

		- Adding an animation to our character during his attack
			+ note - this is easy since we already have the animations for it from Paragon!
		- Add a variable called AttackAnim to the ASCharacter (type = UAnimMontage*) ... allows us to bind in Editor
		- Using UPROPERTY Category = "Attack" to help organize the BP layout
		- for now we use a timer to control moment the projectile spawns ... eventually (better) approach will
			use anim notify or other techniques.

		- completed Lecture 4.3 .... checkpoint code

Commit : Lecture 4.3 : Animations and Timers


Lecture 5.1
	- intro to BPs

Lecture 5.2
	- create a BP class derived from AActor for a "Lever"
	- You can modify the BP so it will implement our C++ interaction interface !
		+ go to Class Settings
		+ Add "SGameplayInterface" to list of Implemented Interfaces
			> recall we had an overridable BPE in this C++ interface! , called "Interact"
		+ We now see the "Interact" function listed in the My Blueprint tab under INTERFACES on the right.
		+ double-click it... you'll now see an event in the event graph to provide BP "code" for this event.

		+ we didn't mark up the "Interact" BPE to be BP Callable though, so we need to edit the code for it now

Lecture 5.3
	- when you implement the "Interact" BPE in Blueprint for the treasure chest, it will OVERRIDE the C++ code in the base class
		so only operations performed in the Blueprint "code" will be executed.
		> (? maybe there's a way to also call the C++ native function directly within the BP code so you could then "append" to
			the C++ code ?)
		> Aha YES - Add Call To Parent Function in BP ... they already though about this

		> right click on the "Event Interact" node in BP graph to place the "Add Call To Parent"

	- introduced the "timeline" node in BP


	- checkpoint code and data:

Commit : Lecture 5.3 : Animating in Blueprint

Lecture 5.4 Projectile Blueprint & Collision

	- more improvements to the projectile with VFX on impact and destroy on impact
	- details discussed about differences between events and functions in BP


Commit : Lecture 5.4 Projectile Blueprint & Collision



Lecture 6 : Debugging Tools

Lectuire 6.1 : Assignment 1 Solution Review

	- note: handy button on right side of BP to reset any properties (that have been adjusted) to the default values
	- note: changes to the default properties in the C++ constructor do not (always? sometimes?) propagate to the running engine via Hot Reload
	- note: UE5.6 physics is still a giant piece of crap! e.g. radial force component has a "Force Strength" and an
		"Impulse Strength". The former seems to do nothing, but I'm not going to take the time to chase it down.

		> Ok I lied ... I took a couple minutes to scan through the UE code and discover the messiness that makes this so confusing.
			1. Take a peek at how WE have set up trhe barrel. Our callback is calling the RadialForceComponent's "FireImpulse()" method directly
				- we never set anything up that will apply the "ForceStrength" force within the components Tick !
			2. So, what the heck is going on here?
				- IT'S CRAP !
				- UE has created the URadialForceComponent with too many responsibilities within a single class !
				- There's actually 2 completely separate interfaces here.
					> "Impulse" Approach : You can set values for the impulse approach and "wire it up" to the "FireImpulse" method. You can
						set the flag to apply the same delta-V to all objects (regardless of their mass). This is NOT physical, but people us
						it alot because it's easier to tune than understanding the physics.
					> "Force" Approach : You can set the ForceStrength , then Activate (or auto-Activate) this component and forces
						will be applied through the logic in the TickComponent. This is FANCY, and includes ability to Tick at specified
						intervals (pulse). Note that for this case the MASS of the objects are taken into consideration since it applies forces
						instead of impulses flagged to apply the same delta-V for all objects.

					> NOTE: You can set up BOTH approaches to work within a single instance ! FANCY - but makes these interfaces quite confusing.

				- I created a BP example "RadialForceBlackHoleBP" : Use this as an example of how things can be "wired up" to implement
					both approaches simultaneously. This "Black Hole" continuously "pulls objects" into it, but every 5 seconds there is
					an impulse applied to all the "trapped" objects that pushes them outward.

					> NOTE: The SCharacter only gets pulled into the black hole whe he jumps (probably physics is not simulating when he's
						in contact with the ground so the controller has complete control of his movement)


Commit : Lecture 6.1 : Assignment 1 Solution Review
